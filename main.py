import os
import pandas as pd
import random
from genetic_algorithm import execute_genAlgorithm, analyze_solution
from linear_regression import (
    load_historical_data,
    train_models_by_grade,
    predict_by_grade,
    generate_classes_from_predictions
)

random.seed(42)


def ensure_data_directory():
    """Ensure that the 'data' directory exists."""
    if not os.path.isdir("data"):
        os.makedirs("data")
        print("Directory 'data' was created automatically.")


def load_inputs():
    """Load all required CSV files for the genetic algorithm."""
    if not os.path.exists("data/classes_data.csv"):
        raise FileNotFoundError(
            "File 'data/classes_data.csv' not found. "
            "Make sure it was generated by the linear regression module."
        )

    df_classes = pd.read_csv("data/classes_data.csv")

    required_files = [
        "data/rooms_data.csv",
        "data/teachers_data.csv",
        "data/schedules_data.csv"
    ]
    for file in required_files:
        if not os.path.exists(file):
            raise FileNotFoundError(f"Required file missing: {file}")

    df_rooms = pd.read_csv("data/rooms_data.csv")
    df_teachers = pd.read_csv("data/teachers_data.csv")
    df_schedules = pd.read_csv("data/schedules_data.csv")

    df_assign = (
        pd.read_csv("data/teacher_assignments.csv")
        if os.path.exists("data/teacher_assignments.csv")
        else None
    )

    return df_classes, df_rooms, df_teachers, df_assign, df_schedules


def expand_lessons(df_classes):
    """Expand each class based on the number of weekly lessons."""
    lesson_instances = []
    for _, row in df_classes.iterrows():
        class_id = row["class_id"]
        subject = row.get("subject", "General")
        lessons = int(row.get("lessons_per_week", 1))
        for i in range(lessons):
            lesson_instances.append(f"{class_id}::{subject}::{i + 1}")
    return lesson_instances


def build_timeslots(df_schedules):
    """Create a list of available timeslots and their metadata."""
    timeslots = df_schedules["schedule_id"].tolist()
    schedule_meta = {}
    for _, r in df_schedules.iterrows():
        tid = r["schedule_id"]
        shift = r.get("shift", "")
        label = f"{shift[0] if shift else ''}{r.get('period', '')}".replace(" ", "")
        schedule_meta[tid] = {
            "weekday": r.get("weekday", ""),
            "shift": shift,
            "period": r.get("period", ""),
            "label": label
        }
    return timeslots, schedule_meta


def build_rooms_capacity(df_rooms):
    """Create a dictionary mapping each room to its capacity."""
    return dict(zip(df_rooms["room_id"], df_rooms["capacity"]))


def build_class_students(df_classes):
    """Return a dictionary with the number of students per class."""
    class_students = {}
    for _, row in df_classes.iterrows():
        cid = row["class_id"]
        class_students[cid] = int(row["num_students"])
    return class_students


def build_teacher_assignment_map(lesson_instances, df_assignments, df_teachers):
    """Assign teachers to lessons (randomly if no mapping is provided)."""
    teacher_of_lesson = {}
    teachers_info = {}

    for _, r in df_teachers.iterrows():
        teachers_info[r["teacher_id"]] = {
            "name": r.get("name"),
            "available_morning": bool(r.get("available_morning", True)),
            "available_afternoon": bool(r.get("available_afternoon", True)),
            "available_evening": bool(r.get("available_evening", False)),
            "max_workload": int(r.get("max_workload", 40)),
            "main_subject": r.get("main_subject", "General")
        }

    teacher_ids = list(teachers_info.keys())
    for idx, lesson in enumerate(lesson_instances):
        teacher_of_lesson[idx] = random.choice(teacher_ids)

    return teacher_of_lesson, teachers_info


def main():
    print("\n" + "=" * 70)
    print("STARTING SCHEDULE ALLOCATION SYSTEM")
    print("=" * 70 + "\n")

    ensure_data_directory()

    # ===========================================================
    # STEP 0: LINEAR REGRESSION - GENERATE CLASSES
    # ===========================================================
    print("=" * 70)
    print("STEP 0: LINEAR REGRESSION - Generating classes_data.csv")
    print("=" * 70)

    classes_file = "data/classes_data.csv"
    historical_file = "data/historical_enrollment_data.csv"

    if os.path.isfile(classes_file):
        print(f"  File {classes_file} already exists.")
        user_input = input("Do you want to regenerate the file? (y/n): ").strip().lower()
        if user_input != "y":
            print("Using existing file.\n")
        else:
            print("Regenerating file...")
            if not os.path.isfile(historical_file):
                print(f"ERROR: File {historical_file} not found.")
                print("Cannot regenerate without historical data.")
                return

            df_hist = load_historical_data(historical_file)
            if df_hist is None or df_hist.empty:
                print("ERROR: Historical DataFrame is empty or invalid.")
                return

            print(f"Historical data loaded: {len(df_hist)} records")
            models = train_models_by_grade(df_hist)
            print(f"Models trained for {len(models)} grades")

            predictions = predict_by_grade(models)
            print(f"Predictions generated for {len(predictions)} grades")

            generate_classes_from_predictions(predictions)
            print("classes_data.csv regenerated successfully.\n")
    else:
        print(f"File {classes_file} not found. Generating...")

        if not os.path.isfile(historical_file):
            print(f"ERROR: File {historical_file} not found.")
            print("Please create a historical enrollment data file first.")
            print(f"\nCheck if 'data' directory exists: {os.path.isdir('data')}")
            if os.path.isdir("data"):
                print(f"Contents of 'data': {os.listdir('data')}")
            return

        print("Loading historical data...")
        df_hist = load_historical_data(historical_file)

        if df_hist is None or df_hist.empty:
            print("ERROR: Historical DataFrame is empty or invalid.")
            return

        print(f"Historical data loaded: {len(df_hist)} records")
        models = train_models_by_grade(df_hist)
        print(f"Models trained for {len(models)} grades")

        predictions = predict_by_grade(models)
        print(f"Predictions generated for {len(predictions)} grades")

        generate_classes_from_predictions(predictions)
        print("classes_data.csv generated successfully.\n")

        if not os.path.isfile(classes_file):
            print(f"ERROR: {classes_file} was not created after execution!")
            if os.path.isdir("data"):
                print(f"Contents of 'data': {os.listdir('data')}")
            return

    print(f"File {classes_file} is ready for use!\n")

    # ===========================================================
    # STEP 1: LOAD INPUTS
    # ===========================================================
    print("=" * 70)
    print("STEP 1: LOAD INPUTS")
    print("=" * 70)

    try:
        df_classes, df_rooms, df_teachers, df_assign, df_schedules = load_inputs()
        print(f"{len(df_classes)} classes loaded from classes_data.csv.")
        print(f"{len(df_rooms)} rooms loaded.")
        print(f"{len(df_teachers)} teachers loaded.")
        print(f"{len(df_schedules)} schedule slots loaded.")
    except Exception as e:
        print(f"ERROR while loading input files: {e}")
        return

    # ===========================================================
    # STEP 2: GENETIC ALGORITHM
    # ===========================================================
    print("=" * 70)
    print("STEP 2: RUN GENETIC ALGORITHM")
    print("=" * 70)

    lesson_instances = expand_lessons(df_classes)
    print(f"Total lessons to schedule: {len(lesson_instances)}")

    timeslots, schedule_meta = build_timeslots(df_schedules)
    rooms = df_rooms["room_id"].tolist()
    rooms_capacity = build_rooms_capacity(df_rooms)
    class_students = build_class_students(df_classes)
    teacher_of_lesson, teacher_info = build_teacher_assignment_map(
        lesson_instances, df_assign, df_teachers
    )

    print("Running genetic algorithm...")
    best, fitness, reasons, mapping = execute_genAlgorithm(
        rooms=rooms,
        timeslots=timeslots,
        lesson_instances=lesson_instances,
        rooms_capacity=rooms_capacity,
        class_students=class_students,
        teacher_of_lesson=teacher_of_lesson,
        teacher_info=teacher_info,
        class_grade_map={},
        ngen=80,
        npop=150
    )

    # ===========================================================
    # STEP 3: REPORT AND ANALYSIS
    # ===========================================================
    print("=" * 70)
    print("STEP 3: REPORT AND ANALYSIS")
    print("=" * 70)

    analyze_solution(
        best,
        fitness,
        reasons,
        mapping,
        lesson_instances,
        df_classes,
        rooms_capacity,
        {lesson: teacher_of_lesson[idx] for idx, lesson in enumerate(lesson_instances)},
        teacher_info,
        schedule_meta
    )

    print("=" * 70)
    print("PROCESS COMPLETED SUCCESSFULLY!")
    print("=" * 70)


if __name__ == "__main__":
    main()
